                                                                           Array Questiions 

QUESTIOIN NO : 896. Monotonic Array

```python
class Solution:
    def isMonotonic(self, nums: List[int]) -> bool:
        increasing = decreasing = True
        
        for i in range(1, len(nums)):
            if nums[i] > nums[i - 1]:
                decreasing = False
            elif nums[i] < nums[i - 1]:
                increasing = False
        
        return increasing or decreasing
```

1. The `Solution` class is defined, which contains the `isMonotonic` method to determine whether a list of numbers is monotonic.

2. `increasing` and `decreasing` are initialized to `True`. These variables will be used to track whether the list is increasing or decreasing.

3. The `for` loop iterates through the `nums` list starting from the second element (index 1). The loop compares each number with its previous number.

4. If `nums[i]` is greater than `nums[i - 1]`, it means the list is not decreasing, so we set `decreasing` to `False`.

5. If `nums[i]` is less than `nums[i - 1]`, it means the list is not increasing, so we set `increasing` to `False`.

6. After iterating through the entire list, the function returns `True` if either `increasing` or `decreasing` is `True`. This means the list is either entirely non-increasing or entirely non-decreasing.

7. If both `increasing` and `decreasing` are `False`, it means the list is neither entirely non-increasing nor entirely non-decreasing, so the function returns `False`.

Here's how the function works with the provided input `nums = [1, 3, 2]`:

- The loop starts with `i = 1`, comparing `3` and `1`. Since `3` is greater than `1`, `decreasing` becomes `False`.
- The loop continues with `i = 2`, comparing `2` and `3`. Since `2` is less than `3`, `increasing` becomes `False`.

At the end of the loop, both `increasing` and `decreasing` are `False`, indicating that the list `[1, 3, 2]` is neither entirely non-increasing nor entirely non-decreasing. Therefore, the function correctly returns `False`, matching the expected output.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

QUESTION NO: 1. Two Sum


```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        seen = {}
        for i, num in enumerate(nums):
            complement = target - num
            if complement in seen:
                return [seen[complement], i]
            seen[num] = i
        return []
```

This code defines a class `Solution` with a method `twoSum` that takes in a list of integers `nums` and an integer `target`, and returns a list of two indices from the input list `nums` such that the corresponding values at those indices sum up to the `target`. If no such indices are found, an empty list is returned.

Now let's break down the code step by step:

1. `seen = {}`: This initializes an empty dictionary `seen` which will be used to store the numbers encountered so far along with their corresponding indices.

2. `for i, num in enumerate(nums):`: This loop iterates through each element in the `nums` list along with its index `i`. The `enumerate` function provides both the index and the value of the element in each iteration.

3. `complement = target - num`: Here, the code calculates the complement of the current `num` by subtracting it from the `target`. The complement is the value that, when added to `num`, results in the `target` sum.

4. `if complement in seen:`: This condition checks if the `complement` calculated in the previous step exists as a key in the `seen` dictionary. If it does, it means that the current `num` complements a number that was previously encountered in the list, and their sum equals the `target`.

5. `return [seen[complement], i]`: If the condition in the previous step is true, the function immediately returns a list containing the indices of the two numbers that sum up to the `target`. The index of the complement (previously encountered number) is retrieved from the `seen` dictionary, and the index of the current `num` is also included in the list.

6. `seen[num] = i`: If the condition in step 4 is not met, the current `num` is added to the `seen` dictionary with its index as the value. This allows the code to keep track of numbers encountered so far.

7. `return []`: If the loop completes without finding a valid pair of indices that sum up to the `target`, the function returns an empty list to indicate that no such pair was found in the input list.

In summary, this code uses a dictionary to keep track of the numbers encountered and their corresponding indices. It iterates through the input list, calculates the complement needed to reach the `target`, and checks if that complement has been encountered before. If so, it returns the indices of the two numbers that form the desired sum; otherwise, it continues iterating.

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->


# QUESTION NO: 961. N-Repeated Element in Size 2N Array

```python
class Solution:
    def repeatedNTimes(self, nums: List[int]) -> int:
        count_map = {}  # This dictionary will store the counts of each element
        n = len(nums)   # Total number of elements in the input list
        target_count = n // 2  # The count we are looking for (N/2)
```

1. `class Solution:`: This defines a class named `Solution`. It's commonly used for encapsulating related functions.

2. `def repeatedNTimes(self, nums: List[int]) -> int:`: This is a method within the `Solution` class named `repeatedNTimes`. It takes an input parameter `nums`, which is a list of integers, and it returns an integer.

3. `count_map = {}`: This initializes an empty dictionary named `count_map`. This dictionary will be used to store the counts of each element in the `nums` list.

4. `n = len(nums)`: This calculates the total number of elements in the input list `nums` and assigns it to the variable `n`.

5. `target_count = n // 2`: This calculates the count we are looking for, which is half of the total number of elements in the list. This is because we are looking for the element that appears more than once, specifically more than `n/2` times.

Now, let's continue with the code:

```python
        for num in nums:
            count_map[num] = count_map.get(num, 0) + 1
            if count_map[num] == target_count:
                return num
```

6. `for num in nums:`: This initiates a loop that iterates over each element `num` in the input list `nums`.

7. `count_map[num] = count_map.get(num, 0) + 1`: This line updates the `count_map` dictionary by incrementing the count of the current `num` by 1. If the `num` is not already a key in the dictionary, the `get` method returns 0 (the second argument) and then adds 1 to it.

8. `if count_map[num] == target_count:`: This checks if the count of the current `num` is equal to the target count (N/2) that we calculated earlier.

9. `return num`: If the count of the current `num` matches the target count, the function returns this `num` as the result. This means the element appears more than `n/2` times in the list and is the repeated element we are looking for.

So, in summary, this code defines a method that takes a list of integers as input, maintains a dictionary to count the occurrences of each element, and returns the element that appears more than `n/2` times in the input list. This is achieved by looping through the input list, updating the count in the dictionary, and checking if the count reaches the target value.

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

# QUESTION NO: 1128. Number of Equivalent Domino Pairs


```python
def numEquivalentDominoPairs(dominoes):
    # Initialize a dictionary to store the frequency of unique domino configurations
    domino_counts = {}
    
    # Initialize a variable to keep track of the total number of equivalent pairs
    total_pairs = 0
    
    # Iterate through the dominoes
    for domino in dominoes:
        # Ensure that the smaller value is first
        domino.sort()
        
        # Calculate a unique identifier for the domino pair
        identifier = tuple(domino)
        
        # Update the count for this identifier in the dictionary
        domino_counts[identifier] = domino_counts.get(identifier, 0) + 1
        
    # Iterate through the dictionary and calculate pairs for each unique identifier
    for count in domino_counts.values():
        if count > 1:
            total_pairs += (count * (count - 1)) // 2
    
    return total_pairs

# Example usage:
dominoes = [[1, 2], [2, 1], [3, 4], [5, 6]]
result = numEquivalentDominoPairs(dominoes)
print(result)  # Output: 1
```

This solution follows the approach explained earlier, where it calculates a unique identifier for each domino pair and uses a dictionary to keep track of their frequencies. It then calculates the number of equivalent pairs for each unique identifier and sums them up to get the total number of equivalent pairs in the given list of dominoes.
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

# QUESTION NO: 27. Remove Element

```python
def removeElement(nums, val):
    i = 0  # Initialize the first pointer
    j = 0  # Initialize the second pointer

    while j < len(nums):
        if nums[j] != val:
            nums[i] = nums[j]
            i += 1
        j += 1

    return i
```

1. **Function Definition**: The function `removeElement` takes two parameters: `nums`, which is the list of integers to be modified, and `val`, which is the value to be removed from the list.

2. **Initialization**: Two pointers, `i` and `j`, are initialized to 0. These pointers will be used to keep track of positions in the `nums` list.

3. **While Loop**: The main part of the algorithm is inside a `while` loop, which iterates through the `nums` list using the `j` pointer.

4. **Comparison**: Inside the loop, there is an `if` statement that checks whether the value at `nums[j]` is not equal to the target value `val`.

5. **Value Copy**: If `nums[j]` is not equal to `val`, it means this element is not to be removed. In this case, the value at `nums[j]` is copied to the position pointed to by `i`, which effectively removes `val` from the list. `i` is then incremented to point to the next available position in the modified list.

6. **Pointer Movement**: Regardless of whether the element is removed or not, the `j` pointer is incremented to continue checking the next element in the original list.

7. **Termination Condition**: The loop continues until `j` reaches the end of the `nums` list.

8. **Result**: After the loop, the function returns the value of `i`. This represents the number of elements in the modified `nums` list that are not equal to `val`. This effectively trims the `nums` list, removing all occurrences of `val`.

The algorithm uses two pointers to traverse the list efficiently, and it performs the removal of elements in-place. As a result, the `nums` list will contain only the elements that are not equal to `val`, and the return value is the count of such elements.

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

# QUESTION NO: 118. Pascal's Triangle


1. **Method Definition**:
   - `class Solution:` defines a class `Solution` to encapsulate the solution to the problem.
   - `def generate(self, numRows: int) -> List[List[int]]:` defines a method `generate` that takes an integer `numRows` as input and returns a list of lists of integers.

2. **Handling Special Cases (Rows 1 and 2)**:
   - The code begins by checking if `numRows` is equal to 1 or 2. If so, it directly returns the corresponding patterns for the first two rows of Pascal's Triangle as nested lists.

3. **Initialization of `lists`**:
   - A list `lists` is initialized with the first two rows of Pascal's Triangle (`[[1], [1, 1]]`) since these two rows are the base cases.

4. **Loop for Generating Rows**:
   - The code enters an `else` block, indicating that it will handle cases beyond the first two rows.
   - It then enters a `for` loop that iterates from `2` (the third row) up to `numRows - 1`, as the first two rows are already included.

5. **Initialization of `temp`**:
   - For each row being generated, an empty list `temp` is initialized. This list will hold the values for the current row.

6. **Loop for Calculating Values in the Current Row**:
   - Within the loop for generating the current row, there's another `for` loop that iterates from `0` to `i` (inclusive), where `i` represents the current row number.

7. **Calculation of Values**:
   - Inside the inner loop, there's a conditional check:
     - If `j` (the current position in the row) is either `0` or `i`, the value `1` is appended to `temp`. These are the edge values of Pascal's Triangle.
     - Otherwise, the value at `temp[j]` is calculated as the sum of the values from the previous row, `lists[i - 1][j - 1]` and `lists[i - 1][j]`.

8. **Appending the Row to `lists`**:
   - Once the `temp` list is populated with values for the current row, it is appended to the `lists` list, representing the growing Pascal's Triangle.

9. **Returning the Result**:
   - After generating all rows up to `numRows`, the final result is the `lists` list, which contains Pascal's Triangle up to the specified number of rows.

The code efficiently generates Pascal's Triangle row by row and returns it as a list of lists, following the pattern of summing the values from the previous row to generate the current row.

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

# QUESTION NO: 2215. Find the Difference of Two Arrays