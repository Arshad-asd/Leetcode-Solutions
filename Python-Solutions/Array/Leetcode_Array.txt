                                                                           Array Questiions 

QUESTIOIN NO : 896. Monotonic Array

```python
class Solution:
    def isMonotonic(self, nums: List[int]) -> bool:
        increasing = decreasing = True
        
        for i in range(1, len(nums)):
            if nums[i] > nums[i - 1]:
                decreasing = False
            elif nums[i] < nums[i - 1]:
                increasing = False
        
        return increasing or decreasing
```

1. The `Solution` class is defined, which contains the `isMonotonic` method to determine whether a list of numbers is monotonic.

2. `increasing` and `decreasing` are initialized to `True`. These variables will be used to track whether the list is increasing or decreasing.

3. The `for` loop iterates through the `nums` list starting from the second element (index 1). The loop compares each number with its previous number.

4. If `nums[i]` is greater than `nums[i - 1]`, it means the list is not decreasing, so we set `decreasing` to `False`.

5. If `nums[i]` is less than `nums[i - 1]`, it means the list is not increasing, so we set `increasing` to `False`.

6. After iterating through the entire list, the function returns `True` if either `increasing` or `decreasing` is `True`. This means the list is either entirely non-increasing or entirely non-decreasing.

7. If both `increasing` and `decreasing` are `False`, it means the list is neither entirely non-increasing nor entirely non-decreasing, so the function returns `False`.

Here's how the function works with the provided input `nums = [1, 3, 2]`:

- The loop starts with `i = 1`, comparing `3` and `1`. Since `3` is greater than `1`, `decreasing` becomes `False`.
- The loop continues with `i = 2`, comparing `2` and `3`. Since `2` is less than `3`, `increasing` becomes `False`.

At the end of the loop, both `increasing` and `decreasing` are `False`, indicating that the list `[1, 3, 2]` is neither entirely non-increasing nor entirely non-decreasing. Therefore, the function correctly returns `False`, matching the expected output.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

QUESTION NO: 1. Two Sum


```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        seen = {}
        for i, num in enumerate(nums):
            complement = target - num
            if complement in seen:
                return [seen[complement], i]
            seen[num] = i
        return []
```

This code defines a class `Solution` with a method `twoSum` that takes in a list of integers `nums` and an integer `target`, and returns a list of two indices from the input list `nums` such that the corresponding values at those indices sum up to the `target`. If no such indices are found, an empty list is returned.

Now let's break down the code step by step:

1. `seen = {}`: This initializes an empty dictionary `seen` which will be used to store the numbers encountered so far along with their corresponding indices.

2. `for i, num in enumerate(nums):`: This loop iterates through each element in the `nums` list along with its index `i`. The `enumerate` function provides both the index and the value of the element in each iteration.

3. `complement = target - num`: Here, the code calculates the complement of the current `num` by subtracting it from the `target`. The complement is the value that, when added to `num`, results in the `target` sum.

4. `if complement in seen:`: This condition checks if the `complement` calculated in the previous step exists as a key in the `seen` dictionary. If it does, it means that the current `num` complements a number that was previously encountered in the list, and their sum equals the `target`.

5. `return [seen[complement], i]`: If the condition in the previous step is true, the function immediately returns a list containing the indices of the two numbers that sum up to the `target`. The index of the complement (previously encountered number) is retrieved from the `seen` dictionary, and the index of the current `num` is also included in the list.

6. `seen[num] = i`: If the condition in step 4 is not met, the current `num` is added to the `seen` dictionary with its index as the value. This allows the code to keep track of numbers encountered so far.

7. `return []`: If the loop completes without finding a valid pair of indices that sum up to the `target`, the function returns an empty list to indicate that no such pair was found in the input list.

In summary, this code uses a dictionary to keep track of the numbers encountered and their corresponding indices. It iterates through the input list, calculates the complement needed to reach the `target`, and checks if that complement has been encountered before. If so, it returns the indices of the two numbers that form the desired sum; otherwise, it continues iterating.

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->


# QUESTION NO: 961. N-Repeated Element in Size 2N Array

```python
class Solution:
    def repeatedNTimes(self, nums: List[int]) -> int:
        count_map = {}  # This dictionary will store the counts of each element
        n = len(nums)   # Total number of elements in the input list
        target_count = n // 2  # The count we are looking for (N/2)
```

1. `class Solution:`: This defines a class named `Solution`. It's commonly used for encapsulating related functions.

2. `def repeatedNTimes(self, nums: List[int]) -> int:`: This is a method within the `Solution` class named `repeatedNTimes`. It takes an input parameter `nums`, which is a list of integers, and it returns an integer.

3. `count_map = {}`: This initializes an empty dictionary named `count_map`. This dictionary will be used to store the counts of each element in the `nums` list.

4. `n = len(nums)`: This calculates the total number of elements in the input list `nums` and assigns it to the variable `n`.

5. `target_count = n // 2`: This calculates the count we are looking for, which is half of the total number of elements in the list. This is because we are looking for the element that appears more than once, specifically more than `n/2` times.

Now, let's continue with the code:

```python
        for num in nums:
            count_map[num] = count_map.get(num, 0) + 1
            if count_map[num] == target_count:
                return num
```

6. `for num in nums:`: This initiates a loop that iterates over each element `num` in the input list `nums`.

7. `count_map[num] = count_map.get(num, 0) + 1`: This line updates the `count_map` dictionary by incrementing the count of the current `num` by 1. If the `num` is not already a key in the dictionary, the `get` method returns 0 (the second argument) and then adds 1 to it.

8. `if count_map[num] == target_count:`: This checks if the count of the current `num` is equal to the target count (N/2) that we calculated earlier.

9. `return num`: If the count of the current `num` matches the target count, the function returns this `num` as the result. This means the element appears more than `n/2` times in the list and is the repeated element we are looking for.

So, in summary, this code defines a method that takes a list of integers as input, maintains a dictionary to count the occurrences of each element, and returns the element that appears more than `n/2` times in the input list. This is achieved by looping through the input list, updating the count in the dictionary, and checking if the count reaches the target value.

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

# QUESTION NO: 1128. Number of Equivalent Domino Pairs


```python
def numEquivalentDominoPairs(dominoes):
    # Initialize a dictionary to store the frequency of unique domino configurations
    domino_counts = {}
    
    # Initialize a variable to keep track of the total number of equivalent pairs
    total_pairs = 0
    
    # Iterate through the dominoes
    for domino in dominoes:
        # Ensure that the smaller value is first
        domino.sort()
        
        # Calculate a unique identifier for the domino pair
        identifier = tuple(domino)
        
        # Update the count for this identifier in the dictionary
        domino_counts[identifier] = domino_counts.get(identifier, 0) + 1
        
    # Iterate through the dictionary and calculate pairs for each unique identifier
    for count in domino_counts.values():
        if count > 1:
            total_pairs += (count * (count - 1)) // 2
    
    return total_pairs

# Example usage:
dominoes = [[1, 2], [2, 1], [3, 4], [5, 6]]
result = numEquivalentDominoPairs(dominoes)
print(result)  # Output: 1
```

This solution follows the approach explained earlier, where it calculates a unique identifier for each domino pair and uses a dictionary to keep track of their frequencies. It then calculates the number of equivalent pairs for each unique identifier and sums them up to get the total number of equivalent pairs in the given list of dominoes.
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

# QUESTION NO: 27. Remove Element

```python
def removeElement(nums, val):
    i = 0  # Initialize the first pointer
    j = 0  # Initialize the second pointer

    while j < len(nums):
        if nums[j] != val:
            nums[i] = nums[j]
            i += 1
        j += 1

    return i
```

1. **Function Definition**: The function `removeElement` takes two parameters: `nums`, which is the list of integers to be modified, and `val`, which is the value to be removed from the list.

2. **Initialization**: Two pointers, `i` and `j`, are initialized to 0. These pointers will be used to keep track of positions in the `nums` list.

3. **While Loop**: The main part of the algorithm is inside a `while` loop, which iterates through the `nums` list using the `j` pointer.

4. **Comparison**: Inside the loop, there is an `if` statement that checks whether the value at `nums[j]` is not equal to the target value `val`.

5. **Value Copy**: If `nums[j]` is not equal to `val`, it means this element is not to be removed. In this case, the value at `nums[j]` is copied to the position pointed to by `i`, which effectively removes `val` from the list. `i` is then incremented to point to the next available position in the modified list.

6. **Pointer Movement**: Regardless of whether the element is removed or not, the `j` pointer is incremented to continue checking the next element in the original list.

7. **Termination Condition**: The loop continues until `j` reaches the end of the `nums` list.

8. **Result**: After the loop, the function returns the value of `i`. This represents the number of elements in the modified `nums` list that are not equal to `val`. This effectively trims the `nums` list, removing all occurrences of `val`.

The algorithm uses two pointers to traverse the list efficiently, and it performs the removal of elements in-place. As a result, the `nums` list will contain only the elements that are not equal to `val`, and the return value is the count of such elements.

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

# QUESTION NO: 118. Pascal's Triangle


1. **Method Definition**:
   - `class Solution:` defines a class `Solution` to encapsulate the solution to the problem.
   - `def generate(self, numRows: int) -> List[List[int]]:` defines a method `generate` that takes an integer `numRows` as input and returns a list of lists of integers.

2. **Handling Special Cases (Rows 1 and 2)**:
   - The code begins by checking if `numRows` is equal to 1 or 2. If so, it directly returns the corresponding patterns for the first two rows of Pascal's Triangle as nested lists.

3. **Initialization of `lists`**:
   - A list `lists` is initialized with the first two rows of Pascal's Triangle (`[[1], [1, 1]]`) since these two rows are the base cases.

4. **Loop for Generating Rows**:
   - The code enters an `else` block, indicating that it will handle cases beyond the first two rows.
   - It then enters a `for` loop that iterates from `2` (the third row) up to `numRows - 1`, as the first two rows are already included.

5. **Initialization of `temp`**:
   - For each row being generated, an empty list `temp` is initialized. This list will hold the values for the current row.

6. **Loop for Calculating Values in the Current Row**:
   - Within the loop for generating the current row, there's another `for` loop that iterates from `0` to `i` (inclusive), where `i` represents the current row number.

7. **Calculation of Values**:
   - Inside the inner loop, there's a conditional check:
     - If `j` (the current position in the row) is either `0` or `i`, the value `1` is appended to `temp`. These are the edge values of Pascal's Triangle.
     - Otherwise, the value at `temp[j]` is calculated as the sum of the values from the previous row, `lists[i - 1][j - 1]` and `lists[i - 1][j]`.

8. **Appending the Row to `lists`**:
   - Once the `temp` list is populated with values for the current row, it is appended to the `lists` list, representing the growing Pascal's Triangle.

9. **Returning the Result**:
   - After generating all rows up to `numRows`, the final result is the `lists` list, which contains Pascal's Triangle up to the specified number of rows.

The code efficiently generates Pascal's Triangle row by row and returns it as a list of lists, following the pattern of summing the values from the previous row to generate the current row.

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

# QUESTION NO: 2215. Find the Difference of Two Arrays


```python
class Solution:
    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:
```

1. **Class Definition and Method Signature**:
   - The code defines a class called `Solution`.
   - Inside this class, there's a method named `findDifference` that takes two lists of integers, `nums1` and `nums2`, as input.
   - It returns a list containing two lists of integers, where the first list contains elements from `nums1` that are not in `nums2`, and the second list contains elements from `nums2` that are not in `nums1`.

```python
        nums1Set, nums2Set = set(nums1), set(nums2)
```

2. **Set Conversion**:
   - The code converts the input lists `nums1` and `nums2` into sets, `nums1Set` and `nums2Set`. Sets are used to efficiently perform set operations like set difference and membership checks.

```python
        res1, res2 = set(), set()
```

3. **Initialization of Result Sets**:
   - Two empty sets, `res1` and `res2`, are initialized. These sets will be used to store the elements that are not common between the two input lists.

```python
        for n in nums1:
            if n not in nums2Set:
                res1.add(n)
```

4. **Iteration Over `nums1`**:
   - The code iterates through the elements of the `nums1` list using a `for` loop.
   - For each element `n` in `nums1`, it checks whether `n` is not in the `nums2Set`.
   - If `n` is not found in `nums2Set`, it means `n` is in `nums1` but not in `nums2`, so it is added to the `res1` set using `res1.add(n)`.

```python
        for n in nums2:
            if n not in nums1Set:
                res2.add(n)
```

5. **Iteration Over `nums2`**:
   - Similarly, the code iterates through the elements of the `nums2` list using another `for` loop.
   - For each element `n` in `nums2`, it checks whether `n` is not in the `nums1Set`.
   - If `n` is not found in `nums1Set`, it means `n` is in `nums2` but not in `nums1`, so it is added to the `res2` set using `res2.add(n)`.

```python
        return [list(res1), list(res2)]
```

6. **Returning the Result**:
   - Finally, the code returns a list containing the elements of `res1` and `res2` as lists. This is done using `[list(res1), list(res2)]`.

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

# QUESTION NO : 2824. Count Pairs Whose Sum is Less than Target


```python
class Solution:
    def countPairs(self, nums: List[int], target: int) -> int:
        count = 0
```

1. **Class Definition**: The code defines a Python class named `Solution`.

2. **Method Definition**: Inside the class, there is a method named `countPairs` which takes three parameters:
   - `self`: This is a reference to the instance of the class.
   - `nums`: A list of integers containing the numbers to be processed.
   - `target`: An integer representing the target sum.

3. **Variable Initialization**: It initializes a variable `count` to 0. This variable will be used to count the pairs of numbers that sum up to the target.

```python
        for i in range(len(nums)):
            for j in range(i+1, len(nums)):
```

4. **Nested Loops**: The code uses two nested `for` loops to iterate through the elements of the `nums` list. The outer loop iterates over `i`, which represents the index of the first number in a potential pair. The inner loop iterates over `j`, which represents the index of the second number in the pair.

5. **Check Pair Sum**: Inside the inner loop, it checks if the sum of the numbers at indices `i` and `j` is less than the target:

```python
               if nums[i] + nums[j] < target:
```

6. **Increment `count`**: If the sum is less than the target, it means the pair of numbers at indices `i` and `j` forms a valid pair that sums up to the target. In this case, the `count` variable is incremented by 1:

```python
                   count += 1
```

7. **Return Result**: After both loops have completed, the method returns the final value of the `count` variable, which represents the total number of pairs in the `nums` list that sum up to the given `target` value.

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

# QUESTION NO : 1200. Minimum Absolute Difference


```python
class Solution:
    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:
        arr.sort()  # Sort the input list 'arr' in ascending order
        min_dif = float('inf')  # Initialize 'min_dif' to positive infinity
        res = []  # Initialize an empty list 'res' to store result pairs

        # Iterate through the sorted 'arr' to find minimum absolute difference pairs
        for i in range(1, len(arr)):
            cur = abs(arr[i] - arr[i - 1])  # Calculate the absolute difference between adjacent elements

            # Check if the current absolute difference is less than the minimum found so far
            if min_dif > cur:
                min_dif = cur  # Update 'min_dif' with the current absolute difference
                res = [[arr[i - 1], arr[i]]]  # Create a new result list with the current pair
            # Check if the current absolute difference is equal to the minimum found so far
            elif min_dif == cur:
                res.append([arr[i - 1], arr[i]])  # Add the current pair to the result list

        return res  # Return the list of pairs with minimum absolute difference
```

Explanation:

1. `arr.sort()`: The input list `arr` is sorted in ascending order. Sorting the array makes it easier to find adjacent elements with minimum absolute differences.

2. `min_dif = float('inf')`: The variable `min_dif` is initialized with positive infinity. This is done to ensure that any calculated absolute difference will be smaller than the initial value of `min_dif` during the first iteration.

3. `res = []`: An empty list `res` is initialized to store the result pairs with the minimum absolute difference.

4. Loop through the sorted `arr` starting from the second element (index 1) with `for i in range(1, len(arr))`.

5. Calculate the absolute difference between the current element (`arr[i]`) and the previous element (`arr[i - 1]`) and store it in the variable `cur`.

6. Check if `cur` is less than the current minimum difference (`min_dif`). If it is, update `min_dif` with the new minimum value (`cur`) and set `res` as a list containing the current pair `[[arr[i - 1], arr[i]]]`. This initializes the result list with the current pair as the minimum absolute difference.

7. If `cur` is equal to the current minimum difference (`min_dif`), append the current pair `[[arr[i - 1], arr[i]]]` to the result list. This handles cases where there are multiple pairs with the same minimum absolute difference.

8. Repeat steps 5-7 for all elements in the sorted `arr`.

9. Finally, return the `res` list containing the pairs with the minimum absolute difference.

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->


# QUESTION NO : 2828. Check if a String Is an Acronym of Words

class Solution:
    def isAcronym(self, words: List[str], s: str) -> bool:
         return ''.join(word[0] for word in words) == s

1 .return boolean value true or false if word[0] string equal to s contains

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

# QUESTION NO : 2798. Number of Employees Who Met the Target

class Solution:
    def numberOfEmployeesWhoMetTarget(self, hours: List[int], target: int) -> int:
        count = 0
        for i in range(len(hours)):
            if hours[i] >= target:
                count += 1
        return count

1.set count =0 initialize
2.iterate through the loop range 0 to len(hours)
3.conditons check if hours[i] >= target then increase the count of value
4.finaly end the loop count will be return 
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

# QUESTION NO : 2553. Separate the Digits in an Array

class Solution:
    def separateDigits(self, nums: List[int]) -> List[int]:
        res = []
        for i in range(len(nums)):
            if nums[i] > 9:
                temp = [int(char) for char in str(nums[i])]
                res.extend(temp)
            else:
                res.append(nums[i])
        return res

1.first initialize res named list
2.iterate through list name nums useing for loop lwn(nums)
3.check conditon if nums[i] > 9 split the digit and store in temp variable and extend res list
4.else the current nums[i] will be add in res list
5.finaly we return res list
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

# QUESTION NO : 2574. Left and Right Sum Differences

```python
class Solution:
    def leftRightDifference(self, nums: List[int]) -> List[int]:
```

- This code defines a Python class named `Solution`.
- Inside the class, there's a method named `leftRightDifference`, which takes a list of integers `nums` as input and returns a list of integers.
- The `-> List[int]` notation specifies that the return type of this method is a list of integers.

Now, let's dive into the code inside the `leftRightDifference` method:

```python
return [abs(sum(nums[:i + 1])-sum(nums[i:])) for i in range(len(nums))]
```

Here's a breakdown of what this line of code does:

1. `for i in range(len(nums))`: This part of the code iterates over the indices `i` from `0` to `len(nums) - 1`. In other words, it goes through each element of the input list `nums`.

2. `nums[:i + 1]`: This part of the code slices the `nums` list from the beginning to the index `i + 1`. It creates a new list containing elements from the start up to and including the element at index `i`.

3. `nums[i:]`: This part of the code slices the `nums` list from index `i` to the end. It creates a new list containing elements from index `i` to the last element.

4. `sum(nums[:i + 1])`: This calculates the sum of the elements in the left portion of the list (from the beginning up to and including the element at index `i`).

5. `sum(nums[i:])`: This calculates the sum of the elements in the right portion of the list (from index `i` to the end).

6. `abs(sum(nums[:i + 1])-sum(nums[i:]))`: This calculates the absolute difference between the sums of the left and right portions of the list.

7. The entire expression is enclosed in a list comprehension, which means it calculates this absolute difference for each `i` in the range and creates a list containing all these absolute differences.

In summary, the `leftRightDifference` method takes an input list of integers, and for each element in the list, it calculates the absolute difference between the sum of the elements to the left of that element and the sum of the elements to the right of that element. It returns a list of these absolute differences.

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

# QUESTION NO : 1331. Rank Transform of an Array

```python
class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        store = {}
        sort_arr = sorted(set(arr))

        for i in range(len(sort_arr)):
            store[sort_arr[i]] = i + 1

        for i in range(len(arr)):
            arr[i] = store[arr[i]]

        return arr
```

This function takes a list of integers `arr` as input and returns a list of integers representing the ranks of the elements in the input list.

Here's a step-by-step explanation:

1. `store` is initialized as an empty dictionary. This dictionary will be used to store the mapping of unique elements in the input list to their corresponding ranks.

2. `set(arr)` is used to create a set containing unique elements from the input list `arr`. This is done to remove duplicate values and ensure that each unique value in the list is assigned a distinct rank.

3. `sorted(set(arr))` sorts the unique elements in ascending order and stores them in the `sort_arr` list. This will be used to determine the ranks.

4. The first loop iterates through `sort_arr`, which contains the unique elements in sorted order. For each unique element, it assigns a rank starting from 1 and stores this mapping in the `store` dictionary. The rank is determined by the index `i` in the sorted list, incremented by 1. This loop ensures that each unique element is assigned a unique rank.

5. After the loop, the `store` dictionary contains mappings of unique elements to their ranks.

6. The second loop iterates through the original input list `arr`. For each element in `arr`, it replaces the element with its corresponding rank from the `store` dictionary. This loop effectively transforms the input list into a list of ranks.

7. Finally, the transformed list of ranks is returned as the output of the `arrayRankTransform` function.

The purpose of this code is to assign ranks to the elements in the input list based on their order in a sorted version of the list. The output list will contain the ranks of the elements in the same order as they appeared in the input list.

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

# QUESTION NO : 2535. Difference Between Element Sum and Digit Sum of an Array
 
 class Solution:
    def differenceOfSum(self, nums: List[int]) -> int:
        temp = [int(digit) for number in nums for digit in str(number)]
        return sum(nums) - sum(temp)

1.Initialize temp variabele for storing conveted tow digit in two in to numbers
2.return difference of sum of nums and temp

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

# QUESTION NO : 2418. Sort the People

class Solution:
    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:
       _,names = zip(*sorted(zip(heights,names),reverse = True))
       return list(names)

1. zip method used to  combaine heights and names reverse and after unzip  the names 
2.return names

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

# QUESTION NO : 1365. How Many Numbers Are Smaller Than the Current Number

1.first initialize a empty list
2.iterate for loop used in nums list using outer loop i and inner loop j and intialize insdie i loop count variabele wtih 0 value assigned
3.check condition if nums[j] < nums[i] and i != j then the counter value increase by one under the j loop exists
4.the j loop will be stop the current count  value add in an result list
5.final return the result list
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

# QUESTION NO : 1389. Create Target Array in the Given Order

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

# QUESTION NO : 2114. Maximum Number of Words Found in Sentences

class Solution:
    def mostWordsFound(self, sentences: List[str]) -> int:
        count = 0
        for i in range(len(sentences)):
                array = sentences[i].split(' ')
                if len(array) > count:
                    count = len(array)
        return count
 
 1. intialize count = 0
 2.for loop used to iterate sentences list
 3.create new array and assign split sentences liss values
 4.check condition len(arry) > count then count assign len(array)
 5.under return count
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->
# QUESTION NO : 1816. Truncate Sentence

class Solution:
    def truncateSentence(self, s: str, k: int) -> str:
        arr = s.split(" ")
        res = ''
        for i in range(k):
           res += arr[i]
           if k-1!=i:
               res += ' '
        return res

1.intialize arr list and assign value splited string , intialize res empty string
2.for loop used to iteate the length of K
3.assign each vaule of arr i position  to res string
4.then checking the k-1 value not equal to i then add the space to the res string
5.finaly return the res string
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->
# QUESTION NO : 1920. Build Array from Permutation
class Solution:
    def buildArray(self, nums: List[int]) -> List[int]:
       ans = []
       for i in range(len(nums)):
           ans.append(nums[nums[i]])
       return ans

1.intialize a ans named empty list
2.for loop used to iterate in the range of 0 to len(nums)
3.append to ans list the nums[nums[i]] ,
4.return the ans list

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

#QUESTION NUMBER : 2367. Number of Arithmetic Triplets

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->
#QUESTION NUMBER : 2006. Count Number of Pairs With Absolute Difference K



<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->