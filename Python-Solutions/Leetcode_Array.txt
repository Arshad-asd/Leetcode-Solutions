                                                                           Array Questiions 

QUESTIOIN NO : 896. Monotonic Array

```python
class Solution:
    def isMonotonic(self, nums: List[int]) -> bool:
        increasing = decreasing = True
        
        for i in range(1, len(nums)):
            if nums[i] > nums[i - 1]:
                decreasing = False
            elif nums[i] < nums[i - 1]:
                increasing = False
        
        return increasing or decreasing
```

1. The `Solution` class is defined, which contains the `isMonotonic` method to determine whether a list of numbers is monotonic.

2. `increasing` and `decreasing` are initialized to `True`. These variables will be used to track whether the list is increasing or decreasing.

3. The `for` loop iterates through the `nums` list starting from the second element (index 1). The loop compares each number with its previous number.

4. If `nums[i]` is greater than `nums[i - 1]`, it means the list is not decreasing, so we set `decreasing` to `False`.

5. If `nums[i]` is less than `nums[i - 1]`, it means the list is not increasing, so we set `increasing` to `False`.

6. After iterating through the entire list, the function returns `True` if either `increasing` or `decreasing` is `True`. This means the list is either entirely non-increasing or entirely non-decreasing.

7. If both `increasing` and `decreasing` are `False`, it means the list is neither entirely non-increasing nor entirely non-decreasing, so the function returns `False`.

Here's how the function works with the provided input `nums = [1, 3, 2]`:

- The loop starts with `i = 1`, comparing `3` and `1`. Since `3` is greater than `1`, `decreasing` becomes `False`.
- The loop continues with `i = 2`, comparing `2` and `3`. Since `2` is less than `3`, `increasing` becomes `False`.

At the end of the loop, both `increasing` and `decreasing` are `False`, indicating that the list `[1, 3, 2]` is neither entirely non-increasing nor entirely non-decreasing. Therefore, the function correctly returns `False`, matching the expected output.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

QUESTION NO: 1. Two Sum


```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        seen = {}
        for i, num in enumerate(nums):
            complement = target - num
            if complement in seen:
                return [seen[complement], i]
            seen[num] = i
        return []
```

This code defines a class `Solution` with a method `twoSum` that takes in a list of integers `nums` and an integer `target`, and returns a list of two indices from the input list `nums` such that the corresponding values at those indices sum up to the `target`. If no such indices are found, an empty list is returned.

Now let's break down the code step by step:

1. `seen = {}`: This initializes an empty dictionary `seen` which will be used to store the numbers encountered so far along with their corresponding indices.

2. `for i, num in enumerate(nums):`: This loop iterates through each element in the `nums` list along with its index `i`. The `enumerate` function provides both the index and the value of the element in each iteration.

3. `complement = target - num`: Here, the code calculates the complement of the current `num` by subtracting it from the `target`. The complement is the value that, when added to `num`, results in the `target` sum.

4. `if complement in seen:`: This condition checks if the `complement` calculated in the previous step exists as a key in the `seen` dictionary. If it does, it means that the current `num` complements a number that was previously encountered in the list, and their sum equals the `target`.

5. `return [seen[complement], i]`: If the condition in the previous step is true, the function immediately returns a list containing the indices of the two numbers that sum up to the `target`. The index of the complement (previously encountered number) is retrieved from the `seen` dictionary, and the index of the current `num` is also included in the list.

6. `seen[num] = i`: If the condition in step 4 is not met, the current `num` is added to the `seen` dictionary with its index as the value. This allows the code to keep track of numbers encountered so far.

7. `return []`: If the loop completes without finding a valid pair of indices that sum up to the `target`, the function returns an empty list to indicate that no such pair was found in the input list.

In summary, this code uses a dictionary to keep track of the numbers encountered and their corresponding indices. It iterates through the input list, calculates the complement needed to reach the `target`, and checks if that complement has been encountered before. If so, it returns the indices of the two numbers that form the desired sum; otherwise, it continues iterating.

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->
